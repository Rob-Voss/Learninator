<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: lib/Grid.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: lib/Grid.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Original code borrowed from https://github.com/felipecsl/random-maze-generator
 *
 */
(function (global) {
    "use strict";

    /**
     * Options for the Grid
     * @typedef {Object} gridOpts
     * @param {number} xCount - The horizontal Cell count
     * @param {number} yCount - The vertical Cell count
     * @param {number} width - The width
     * @param {number} height - The height
     */

    /**
     * Create a cell
     * @name Cell
     * @constructor
     *
     * @param {number} x
     * @param {number} y
     * @param {number} width
     * @param {number} height
     * @returns {Cell}
     */
    var Cell = function (x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.visited = false;
        this.parent = null;
        this.heuristic = 0;
        this.reward = 0;
        this.population = [];
        this.populationCounts = {};

        this.coords = {
            top: {
                left: {
                    x: this.x * this.width,
                    y: this.y * this.height
                },
                right: {
                    x: this.x * this.width + this.width,
                    y: this.y * this.height
                }
            },
            bottom: {
                left: {
                    x: this.x * this.width,
                    y: this.y * this.height + this.height
                },
                right: {
                    x: this.x * this.width + this.width,
                    y: this.y * this.height + this.height
                }
            }
        };

        return this;
    };

    Cell.prototype = {
        /**
         * Calculate the path to the origin
         * @returns {Array}
         */
        pathToOrigin: function () {
            var path = [this],
                p = this.parent;

            while (p) {
                path.push(p);
                p = p.parent;
            }
            path.reverse();

            return path;
        },
        /**
         * Score
         * @returns {number}
         */
        score: function () {
            var total = 0,
                p = this.parent;

            while (p) {
                ++total;
                p = p.parent;
            }

            return total;
        },
        /**
         * Mark it as visited
         * @return {Cell}
         */
        visit: function () {
            this.visited = true;

            return this;
        }
    };

    /**
     * Grid
     * @name Grid
     * @constructor
     *
     * @param {gridOpts} opts - The options for the Grid
     * @returns {Grid}
     */
    var Grid = function (opts) {
        this.xCount = Utility.getOpt(opts, 'xCount', 6);
        this.yCount = Utility.getOpt(opts, 'yCount', 6);
        this.width = Utility.getOpt(opts, 'width', 600);
        this.height = Utility.getOpt(opts, 'height', 600);
        this.cellWidth = this.width / this.xCount;
        this.cellHeight = this.height / this.yCount;

        this.removedEdges = [];
        this.cells = [];
        this.path = [];

        var row, c;
        for (let i = 0; i &lt; this.xCount; i++) {
            this.cells.push([]);
            row = this.cells[i];
            for (let j = 0; j &lt; this.yCount; j++) {
                c = new Cell(i, j, this.cellWidth, this.cellHeight);
                row.push(c);
            }
        }

        return this;
    };

    Grid.prototype = {
        /**
         * Returns true if there is an edge between c1 and c2
         * @param {Cell} c1
         * @param {Cell} c2
         * @returns {boolean}
         */
        areConnected: function (c1, c2) {
            if (!c1 || !c2) {
                return false;
            }

            if (Math.abs(c1.x - c2.x) > 1 || Math.abs(c1.y - c2.y) > 1) {
                return false;
            }

            var removedEdge = _.detect(this.removedEdges, function (edge) {
                return _.include(edge, c1) &amp;&amp; _.include(edge, c2);
            });

            return removedEdge === undefined;
        },
        /**
         * Returns all neighbors of this Cell that are separated by an edge
         * @param {Cell} c
         * @returns {Array}
         */
        connectedNeighbors: function (c) {
            var _this = this, con;
            return _.select(this.neighbors(c), function (c0) {
                con = _this.areConnected(c, c0);

                return con;
            });
        },
        /**
         * Returns all neighbors of this Cell that are NOT separated by an edge
         * This means there is a maze path between both cells.
         * @param {Cell} c
         * @returns {Array}
         */
        disconnectedNeighbors: function (c) {
            var _this = this, disc;
            return _.reject(this.neighbors(c), function (c0) {
                disc = _this.areConnected(c, c0);

                return disc;
            });
        },
        /**
         * Get a Cell at a specific point
         * @param {number} x
         * @param {number} y
         * @returns {Cell}
         */
        getCellAt: function (x, y) {
            if (x >= this.xCount || y >= this.yCount || x &lt; 0 || y &lt; 0 || !this.cells[x]) {
                return null;
            }

            return this.cells[x][y];
        },
        /**
         * Get the distance between two Cells
         * @param {Cell} c1
         * @param {Cell} c2
         * @returns {number}
         */
        getCellDistance: function (c1, c2) {
            var xDist = Math.abs(c1.x - c2.x),
                yDist = Math.abs(c1.y - c2.y);

            return Math.sqrt(Math.pow(xDist, 2) + Math.pow(yDist, 2));
        },
        /**
         * Return the centered location of the entity within a grid
         * @param {Cell} c
         * @returns {Object}
         */
        getPositionFromGridLocation: function (c) {
            let x = c.coords.bottom.right.x - (this.cellWidth / 2),
                y = c.coords.bottom.right.y - (this.cellHeight / 2);

            return new Vec(x, y);
        },
        /**
         * Return the location of the entity within a grid
         * @param {Entity} entity
         * @returns {Object}
         */
        getGridLocation: function (entity) {
            var xCell, yCell;
            for (let x = 0; x &lt; this.xCount; x++) {
                xCell = this.cells[x];
                for (let y = 0; y &lt; this.yCount; y++) {
                    yCell = xCell[y];
                    if ((entity.position.x >= yCell.coords.top.left.x &amp;&amp; entity.position.x &lt;= yCell.coords.bottom.right.x) &amp;&amp;
                        (entity.position.y >= yCell.coords.top.left.y &amp;&amp; entity.position.y &lt;= yCell.coords.bottom.right.y)) {
                        entity.gridLocation = this.cells[x][y];

                        return entity;
                    }
                }
            }
        },
        /**
         * Returns all neighbors of this cell, regardless if they are connected or not.
         * @param {Cell} c
         * @returns {Array}
         */
        neighbors: function (c) {
            var neighbors = [],
                topCell = this.getCellAt(c.x, c.y - 1),
                rightCell = this.getCellAt(c.x + 1, c.y),
                bottomCell = this.getCellAt(c.x, c.y + 1),
                leftCell = this.getCellAt(c.x - 1, c.y);

            if (c.y > 0 &amp;&amp; topCell) {
                neighbors.push(topCell);
            }
            if (c.x &lt; this.xCount &amp;&amp; rightCell) {
                neighbors.push(rightCell);
            }
            if (c.y &lt; this.yCount &amp;&amp; bottomCell) {
                neighbors.push(bottomCell);
            }
            if (c.x > 0 &amp;&amp; leftCell) {
                neighbors.push(leftCell);
            }

            return neighbors;
        },
        /**
         * Remove the edge from between two Cells
         * @param {Cell} c1
         * @param {Cell} c2
         */
        removeEdgeBetween: function (c1, c2) {
            this.removedEdges.push([c1, c2]);
        },
        /**
         * Returns all neighbors of this Cell that aren't separated by an edge
         * @param {Cell} c
         * @returns {boolean}
         */
        unvisitedNeighbors: function (c) {
            var unv;
            return _.select(this.connectedNeighbors(c), function (c0) {
                unv = !c0.visited;
                return unv;
            });
        }
    };

    global.Cell = Cell;
    global.Grid = Grid;

}(this));
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Agent.html">Agent</a></li><li><a href="AgentGA.html">AgentGA</a></li><li><a href="AgentRLDQN.html">AgentRLDQN</a></li><li><a href="AgentRLTD.html">AgentRLTD</a></li><li><a href="AgentTD.html">AgentTD</a></li><li><a href="Bitmap.html">Bitmap</a></li><li><a href="BruteCD.html">BruteCD</a></li><li><a href="Button.html">Button</a></li><li><a href="Camera.html">Camera</a></li><li><a href="Cell.html">Cell</a></li><li><a href="Chromosome.html">Chromosome</a></li><li><a href="CollisionDetector.html">CollisionDetector</a></li><li><a href="datGUI.html">datGUI</a></li><li><a href="DeterministPG.html">DeterministPG</a></li><li><a href="Display.html">Display</a></li><li><a href="DPAgent.html">DPAgent</a></li><li><a href="DQNAgent.html">DQNAgent</a></li><li><a href="Entity.html">Entity</a></li><li><a href="EntityRLDQN.html">EntityRLDQN</a></li><li><a href="ESPNet.html">ESPNet</a></li><li><a href="ESPTrainer.html">ESPTrainer</a></li><li><a href="Eye.html">Eye</a></li><li><a href="GATrainer.html">GATrainer</a></li><li><a href="Graph.html">Graph</a></li><li><a href="Grid.html">Grid</a></li><li><a href="GridCD.html">GridCD</a></li><li><a href="GridWorld.html">GridWorld</a></li><li><a href="HeCubex.html">HeCubex</a></li><li><a href="Hex.html">Hex</a></li><li><a href="HexGrid.html">HexGrid</a></li><li><a href="HexWorld.html">HexWorld</a></li><li><a href="Interactions.html">Interactions</a></li><li><a href="Map.html">Map</a></li><li><a href="Mat.html">Mat</a></li><li><a href="Maze.html">Maze</a></li><li><a href="MazeWorld.html">MazeWorld</a></li><li><a href="Menu.html">Menu</a></li><li><a href="Player.html">Player</a></li><li><a href="Point.html">Point</a></li><li><a href="PuckWorld.html">PuckWorld</a></li><li><a href="QuadCD.html">QuadCD</a></li><li><a href="QuadTree.html">QuadTree</a></li><li><a href="RecurrentReinforceAgent.html">RecurrentReinforceAgent</a></li><li><a href="RewardGraph.html">RewardGraph</a></li><li><a href="SimpleReinforceAgent.html">SimpleReinforceAgent</a></li><li><a href="Solver.html">Solver</a></li><li><a href="TDAgent.html">TDAgent</a></li><li><a href="Vec.html">Vec</a></li><li><a href="Wall.html">Wall</a></li><li><a href="WaterWorld.html">WaterWorld</a></li><li><a href="WaterWorldEX.html">WaterWorldEX</a></li><li><a href="WaterWorldGA.html">WaterWorldGA</a></li><li><a href="Window.html">Window</a></li><li><a href="World.html">World</a></li><li><a href="%257Bobject%257D%2520input.html">{object} input</a></li></ul><h3>Global</h3><ul><li><a href="global.html#clear">clear</a></li><li><a href="global.html#clone">clone</a></li><li><a href="global.html#divide">divide</a></li><li><a href="global.html#EZGUI">EZGUI</a></li><li><a href="global.html#findByAngle">findByAngle</a></li><li><a href="global.html#findByName">findByName</a></li><li><a href="global.html#findInsertNode">findInsertNode</a></li><li><a href="global.html#findOverlappingNodes">findOverlappingNodes</a></li><li><a href="global.html#initSensors">initSensors</a></li><li><a href="global.html#insert">insert</a></li><li><a href="global.html#isAndroid">isAndroid</a></li><li><a href="global.html#isChrome">isChrome</a></li><li><a href="global.html#isFirefox">isFirefox</a></li><li><a href="global.html#isGecko">isGecko</a></li><li><a href="global.html#isIE">isIE</a></li><li><a href="global.html#isIOS">isIOS</a></li><li><a href="global.html#isIPad">isIPad</a></li><li><a href="global.html#isIPhone">isIPhone</a></li><li><a href="global.html#isIPod">isIPod</a></li><li><a href="global.html#isKindle">isKindle</a></li><li><a href="global.html#isMobile">isMobile</a></li><li><a href="global.html#isOpera">isOpera</a></li><li><a href="global.html#isSafari">isSafari</a></li><li><a href="global.html#isTablet">isTablet</a></li><li><a href="global.html#isTV">isTV</a></li><li><a href="global.html#isWebKit">isWebKit</a></li><li><a href="global.html#resetSensors">resetSensors</a></li><li><a href="global.html#retrieve">retrieve</a></li><li><a href="global.html#Utility">Utility</a></li><li><a href="global.html#whoami">whoami</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.3</a> on Thu Dec 03 2015 10:30:02 GMT-0800 (PST)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
